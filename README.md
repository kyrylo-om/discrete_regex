# Лабораторна робота №3. Скінченні автомати

В цій лабораторній роботі я створив базовий недетермінований скінченний автомат, що будується на умовах регулярного виразу і може приймати або не приймати стрічки, проходячись станами і перевіряючи виконання цією стрічкою умов регулярного виразу.

## Стани

В моїй реалізації скінченного автомату стани зберігаються як екземпляри відповідного класу. Зараз в коді є сім можливих станів, і, відповідно, сім класів: StartState, TerminationState, AsciiState, DotState, StarState, PlusState та GroupState. Вони всі наслідують абстрактний клас State, що визначає необхідні кожному класові абстрактні методи: `__init__()` та `check_self()`. `__init__()` створює порожню змінну екземпляру next_states, в якій зберігаються всі стани, до яких цей стан має зв'язки, а `check_self(char)` перевіряє виконання символом `char` умови стану.

### StartState

Це стартовий стан. З нього починається будь-який автомат. По факту, він не виконує ніякої ролі, окрім як слугує точкою входу в автомат, тому йому навіть не потрібна функція `check_self()` - вона ніколи не викликається.

### TerminationState

Це кінцевий стан автомату. Він теж, великою мірою, умовний, адже не виконує ніякої ролі окрім як слугує прапорцем для автомату, що говорить, що стрічка має бути прийнята. Якщо автомат заходить в TerminationState на будь-якому етапі перевірки стрічки (за умови, що вона закінчилась, звісно), він приймає її.

### AsciiState

Базовий стан. Тримає в собі один ASCII символ і перевіряє його співпадіння з символом, що входить.

### DotState

Приймає будь-який ASCII символ. Функція `check_self()` цього класу завжди повертає True.

### StarState

Найкомплексніший, чи, скоріше, унікальний стан. При ініціалізації додає самого себе в свої `next_states` (тобто робить стрілку до самого себе, адже цей стан може повторюватись безліч разів) і приймає аргумент `checking_state`, який виконує функцію перевірки умови для цього стану. По факту, StarState - це стан зі станом усередині, де останній виконує всі перевірки, а сам StarState потрібен лише для того, щоб зчитувач стрічки потім зміг застосувати до нього унікальні дії, а саме безкоштовно перейти до нього, не виконуючи його умову і не читаючи символ у стрічці.

Насправді, тут я імітую епсілон-стрілку, але через те, що в цій імпленентації скінченного автомату умову переходу в наступний стан зберігає не стрілка, а стан, всі переходи до будь-якого стану можуть мати лише одну умову - умову цього стану. Це не зовсім коректна реалізація автомату, але для поставленої задачі вона працює досить добре, адже епсилон-стрілки потрібні тільки в стані зірки, щоб її можна було пропустити. Бо вона приймає 0 або більше повторень.

### PlusState

Робить все те саме, що і StarState. Єдина відмінність у тому, що зчитувач стрічки не сприймає його як StarState і тому не додає до нього уявну епсилон-стрілку. Це значить, що зчитувач не може перейти в цей стан безкоштовно - він має виконати його умову. Все як у стандартних станах.

### GroupState

Стан з додаткової задачі. Його імплементація найдовша, але насправді він досить простий, адже більшу частину роботи робить компілятор, коли зчитує групу і намагається зрозуміти, де вона закривається і чи не порушений синтаксис. В сам стан компілятором передається чиста група з всіма символами, які вона може приймати. Також підтримується функціонал range, тобто група 1-9 буде приймати будь-який символ з диапазону від 1 до 9.

## Компілятор

Компіляція скінченного автомату відбувається в функції `__init__()` класу RegexFSM. Вона приймає як аргумент патерн і перетворює його на скінченний автомат.

Спочатку береться початковий стан, який не залежить від патерну - він є початком автомату. Далі функція ітерується по кожному символу в патерні, і створює для нього стан. Наприклад, якщо функція побачить в патерні символ а, то вона створює AsciiState, що тримає символ а. Перед тим як перейти до наступної ітерації циклу, функція дивиться на наступний символ в патерні, і якщо бачить там * або +, створює стан StarState або PlusState відповідно, передаючи як аргумент до них попередньо створений AsciiState (або будь-який інший). Таким чином, в кінці ітерації наступним станом автомату стає лише останній створений, тобто якщо функція побачила зірочку після поточного символу, вона додасть до автомату лише стан зірочки.

Групи зчитуються тоді ж, коли і звичайні ASCII символи, просто наступна ітерація на починається допоки функція не зчитає всю групу. Вона робить це таким чином, що, після того як побачила відкриту квадратну дужку [ , одразу шукає позицію закритої дужки в патерні, і, якщо знаходить, створює стан GroupState, в який передає всі символи в середині квадратних дужок. Якщо не знаходить - викликає помилку.

В кінці компілятор додає до останнього створеного стану перехід в TerminationState, позначаючи кінець автомата.

## Зчитувач стрічки

Це найцікавіше. Мені дуже подобається імплементація зчитувача, тому що вона дуже коротка і елегантна, але в той самий час дуже потужна.

Проблема з недетермінованими автоматами в тому, що іноді, в деяких ситуаціях зчитувачі, такі як цей, будуть мати декілька варіантів того, в який стан перейти далі. Саме тому, щоб коректно визначити, чи прийме автомат стрічку, потрібно пройтись по всім можливим шляхам у автоматі. Для цього мені ідеально підійшов алгоритм DFS.

Якщо коротко, зчитувач лише запускає алгоритм DFS, і якщо хоч один шлях доходить до термінального стану, зчитувач приймає стрічку.

Тепер - як працює DFS і чому стан зірочки в моїй імплементації автомату такий унікальний. Все, що робить DFS - це приймає на вхід поточний стан і "глибину" - тобто індекс поточного символа в стрічці, а далі проходиться по кожному стану з `next_states`, і, якщо його умова виконується для поточного символу, запускає DFS в цьому наступному стані з глибиною, збільшеною на 1. Іншими словами, просто зчитує поточний символ і переходить в наступний стан.

Цікавіше стається тоді, коли DFS бачить серед наступних станів стан зірочки. В такому випадку він запускає DFS в цьому стані, але не збільшує глибину, а залишає її такою ж, як і була. Це означає, що зчитувач переходить до наступного стану (тобто стану зірочки) безкоштовно, не зчитуючи символ. Це і є епсилон-стрілка.

В кінці кінців, якщо DFS бачить серед наступних станів термінальний стан, він повертає True, і зчитувач приймає стрічку. Якщо ж зчитувач в кінці кінців не доходить до жодного термінального стану, він не приймає стрічку.